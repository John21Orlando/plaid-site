<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Plaid Maker (Course Prototype)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    header { display:flex; align-items:center; gap:12px; padding:16px 20px; border-bottom:1px solid #ddd; }
    header b { font-size: 22px; }
    main { display:grid; grid-template-columns: 380px 1fr; gap: 16px; padding: 16px 20px; }
    .panel { border:1px solid #ddd; border-radius:10px; padding:14px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:12px; margin:10px 0; }
    .row label { font-weight:600; }
    .colors { display:flex; flex-direction:column; gap:8px; }
    .colorItem { display:flex; align-items:center; gap:10px; }
    .colorItem input[type="text"] { width:110px; padding:6px 8px; }
    .swatch { width:26px; height:26px; border-radius:6px; border:1px solid #ccc; }
    textarea { width:100%; height:90px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    canvas { width:100%; height:auto; border:1px solid #ddd; border-radius:10px; background:#fff; }
    .hint { font-size: 12px; color:#555; line-height:1.35; }
    button { padding:10px 12px; border-radius:10px; border:1px solid #bbb; background:#fff; cursor:pointer; }
    button:hover { background:#f6f6f6; }
  </style>
</head>
<body>
<header>
  <b>PlaidMaker (Rebuild Prototype)</b>
  <span class="hint">Course use: rebuild behavior, don’t reuse their code/assets.</span>
</header>

<main>
  <section class="panel">
    <h2 style="margin:0 0 8px;">Make a Plaid</h2>

    <div class="row">
      <label>Twill</label>
      <select id="twill">
        <option value="1x1">1x1</option>
        <option value="none">None</option>
      </select>
    </div>

    <div class="row">
      <label>Colors</label>
      <button id="addColor">+ Add</button>
    </div>

    <div class="colors" id="colors"></div>
    <p class="hint">Hex format: <code>#19CFCF</code>. The swatch updates automatically.</p>

    <hr />

    <div class="row">
      <label>Warp (X stripes)</label>
      <label style="font-weight:500">
        <input type="checkbox" id="xMirror" /> Mirror
      </label>
    </div>
    <textarea id="warpStripes" spellcheck="false"></textarea>
    <p class="hint">
      One stripe per line: <code>colorIndex,widthPx</code><br/>
      Example: <code>0,12</code> means color 0 with width 12px.
    </p>

    <div class="row">
      <label>Weft (Y stripes)</label>
      <label style="font-weight:500">
        <input type="checkbox" id="yMirror" /> Mirror
      </label>
    </div>

    <div class="row">
      <label style="font-weight:500">
        <input type="checkbox" id="weftSame" /> Same as warp
      </label>
    </div>

    <textarea id="weftStripes" spellcheck="false"></textarea>

    <hr />

    <div class="row">
      <button id="saveLink">Copy Share Link</button>
      <button id="reset">Reset</button>
    </div>
    <p class="hint" id="status"></p>
  </section>

  <section class="panel">
    <h2 style="margin:0 0 8px;">Preview</h2>
    <canvas id="cv" width="900" height="520"></canvas>
  </section>
</main>

<script>
  // ---------- Utilities ----------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function hexToRgb(hex){
    const h = hex.replace('#','').trim();
    if(!/^[0-9a-fA-F]{6}$/.test(h)) return null;
    const n = parseInt(h,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgbToHex({r,g,b}){
    const to2 = v => v.toString(16).padStart(2,'0');
    return '#' + to2(r) + to2(g) + to2(b);
  }
  function mix(a,b,t){
    return {
      r: Math.round(a.r*(1-t)+b.r*t),
      g: Math.round(a.g*(1-t)+b.g*t),
      b: Math.round(a.b*(1-t)+b.b*t),
    };
  }
  function darken(rgb, amount){ // amount 0..1
    return mix(rgb, {r:0,g:0,b:0}, clamp01(amount));
  }
  function lighten(rgb, amount){
    return mix(rgb, {r:255,g:255,b:255}, clamp01(amount));
  }

  // ---------- State ----------
  const DEFAULT = {
    colors: ['#19CFCF', '#FF0000', '#FFFFFF'],
    x_mirror: true,
    y_mirror: true,
    weft_same: true,
    twill: '1x1',
    warp: [{c:0,w:12},{c:1,w:12},{c:2,w:12}],
    weft: []
  };

  const el = {
    colorsBox: document.getElementById('colors'),
    addColor: document.getElementById('addColor'),
    xMirror: document.getElementById('xMirror'),
    yMirror: document.getElementById('yMirror'),
    weftSame: document.getElementById('weftSame'),
    warpStripes: document.getElementById('warpStripes'),
    weftStripes: document.getElementById('weftStripes'),
    twill: document.getElementById('twill'),
    cv: document.getElementById('cv'),
    saveLink: document.getElementById('saveLink'),
    reset: document.getElementById('reset'),
    status: document.getElementById('status')
  };

  let S = structuredClone(DEFAULT);

  // ---------- Parse/Serialize hash (similar spirit to PlaidMaker) ----------
  function serializeToHash(){
    // colors=19CFCF,FF0000,ffffff&twill=1x1&x_mirror=1&x_str=0x12,1x12,2x12&y_mirror=1&y_same=1&y_str=...
    const colors = S.colors.map(h=>h.replace('#','')).join(',');
    const x_str = S.warp.map(s => `${s.c}x${s.w}`).join(',');
    const y_str = (S.weft_same ? '' : S.weft.map(s => `${s.c}x${s.w}`).join(','));
    const params = new URLSearchParams();
    params.set('colors', colors);
    params.set('twill', S.twill);
    params.set('x_mirror', S.x_mirror ? '1' : '0');
    params.set('y_mirror', S.y_mirror ? '1' : '0');
    params.set('y_same', S.weft_same ? '1' : '0');
    params.set('x_str', x_str);
    if(!S.weft_same) params.set('y_str', y_str);
    return '#' + params.toString();
  }

  function parseHash(){
    const h = location.hash.startsWith('#') ? location.hash.slice(1) : '';
    if(!h) return false;
    const p = new URLSearchParams(h);

    const colorsRaw = p.get('colors');
    if(colorsRaw){
      const arr = colorsRaw.split(',').map(x => '#'+x.trim());
      if(arr.every(x => hexToRgb(x))) S.colors = arr;
    }
    const tw = p.get('twill'); if(tw) S.twill = tw;
    S.x_mirror = p.get('x_mirror') === '1';
    S.y_mirror = p.get('y_mirror') === '1';
    S.weft_same = p.get('y_same') !== '0';

    const xStr = p.get('x_str');
    if(xStr){
      const warp = xStr.split(',').map(tok=>{
        const [c,w] = tok.split('x');
        return { c: parseInt(c,10), w: parseInt(w,10) };
      }).filter(s => Number.isFinite(s.c) && Number.isFinite(s.w) && s.w>0);
      if(warp.length) S.warp = warp;
    }

    const yStr = p.get('y_str');
    if(!S.weft_same && yStr){
      const weft = yStr.split(',').map(tok=>{
        const [c,w] = tok.split('x');
        return { c: parseInt(c,10), w: parseInt(w,10) };
      }).filter(s => Number.isFinite(s.c) && Number.isFinite(s.w) && s.w>0);
      S.weft = weft;
    }
    return true;
  }

  // ---------- UI ----------
  function renderColorInputs(){
    el.colorsBox.innerHTML = '';
    S.colors.forEach((hex, i)=>{
      const row = document.createElement('div');
      row.className = 'colorItem';

      const inp = document.createElement('input');
      inp.type = 'text';
      inp.value = hex.toUpperCase();
      inp.addEventListener('input', ()=>{
        const v = inp.value.trim();
        if(hexToRgb(v)) {
          S.colors[i] = v.startsWith('#') ? v : '#'+v;
          sw.style.background = S.colors[i];
          schedule();
        }
      });

      const sw = document.createElement('div');
      sw.className = 'swatch';
      sw.style.background = hex;

      const del = document.createElement('button');
      del.textContent = 'Delete';
      del.addEventListener('click', ()=>{
        if(S.colors.length <= 2) return;
        S.colors.splice(i,1);
        // also clamp stripe color indices
        S.warp.forEach(s => s.c = Math.min(s.c, S.colors.length-1));
        S.weft.forEach(s => s.c = Math.min(s.c, S.colors.length-1));
        syncTextareas();
        schedule();
        renderColorInputs();
      });

      row.append(inp, sw, document.createTextNode(' index '+i+' '), del);
      el.colorsBox.appendChild(row);
    });
  }

  function stripesToText(arr){
    return arr.map(s => `${s.c},${s.w}`).join('\n');
  }
  function textToStripes(txt){
    return txt.split('\n')
      .map(line => line.trim())
      .filter(Boolean)
      .map(line=>{
        const [c,w] = line.split(',').map(x=>x.trim());
        return { c: parseInt(c,10), w: parseInt(w,10) };
      })
      .filter(s => Number.isFinite(s.c) && Number.isFinite(s.w) && s.w>0);
  }

  function syncUI(){
    el.xMirror.checked = S.x_mirror;
    el.yMirror.checked = S.y_mirror;
    el.weftSame.checked = S.weft_same;
    el.twill.value = S.twill;
    el.weftStripes.disabled = S.weft_same;

    el.warpStripes.value = stripesToText(S.warp);
    if(S.weft_same){
      el.weftStripes.value = '(Same as warp)';
    } else {
      el.weftStripes.value = stripesToText(S.weft.length ? S.weft : S.warp);
    }
    renderColorInputs();
  }

  function syncTextareas(){
    el.warpStripes.value = stripesToText(S.warp);
    if(!S.weft_same) el.weftStripes.value = stripesToText(S.weft);
  }

  el.addColor.addEventListener('click', ()=>{
    S.colors.push('#CCCCCC');
    renderColorInputs();
    schedule();
  });

  el.xMirror.addEventListener('change', ()=>{ S.x_mirror = el.xMirror.checked; schedule(); });
  el.yMirror.addEventListener('change', ()=>{ S.y_mirror = el.yMirror.checked; schedule(); });
  el.weftSame.addEventListener('change', ()=>{
    S.weft_same = el.weftSame.checked;
    el.weftStripes.disabled = S.weft_same;
    if(S.weft_same) S.weft = [];
    else S.weft = textToStripes(el.weftStripes.value) || structuredClone(S.warp);
    syncUI();
    schedule();
  });
  el.twill.addEventListener('change', ()=>{ S.twill = el.twill.value; schedule(); });

  el.warpStripes.addEventListener('input', ()=>{
    const arr = textToStripes(el.warpStripes.value);
    if(arr.length){
      S.warp = arr.map(s=>({c: Math.min(Math.max(s.c,0), S.colors.length-1), w:s.w}));
      if(S.weft_same) syncUI();
      schedule();
    }
  });

  el.weftStripes.addEventListener('input', ()=>{
    if(S.weft_same) return;
    const arr = textToStripes(el.weftStripes.value);
    if(arr.length){
      S.weft = arr.map(s=>({c: Math.min(Math.max(s.c,0), S.colors.length-1), w:s.w}));
      schedule();
    }
  });

  el.saveLink.addEventListener('click', async ()=>{
    const hash = serializeToHash();
    const url = location.origin + location.pathname + hash;
    try{
      await navigator.clipboard.writeText(url);
      el.status.textContent = 'Copied link to clipboard.';
    } catch {
      el.status.textContent = 'Could not auto-copy. Here is the link: ' + url;
    }
  });

  el.reset.addEventListener('click', ()=>{
    S = structuredClone(DEFAULT);
    location.hash = '';
    syncUI();
    schedule(true);
  });

  // ---------- Plaid renderer ----------
  function mirrorStripes(stripes){
    // Mirror by appending reversed (without duplicating last stripe to avoid hard seam)
    const rev = stripes.slice().reverse();
    return stripes.concat(rev);
  }

  function expandToColorPerPixel(stripes, colors, mirrorFlag){
    let seq = stripes.slice();
    if(mirrorFlag) seq = mirrorStripes(seq);

    const total = seq.reduce((sum,s)=>sum+s.w,0);
    const out = new Array(total);
    let k = 0;
    for(const s of seq){
      const c = colors[Math.min(Math.max(s.c,0), colors.length-1)];
      const rgb = hexToRgb(c) || {r:200,g:200,b:200};
      for(let i=0;i<s.w;i++) out[k++] = rgb;
    }
    return out; // length = period in pixels
  }

  function render(){
    const ctx = el.cv.getContext('2d', { willReadFrequently: true });
    const W = el.cv.width, H = el.cv.height;

    const warpRGB = expandToColorPerPixel(S.warp, S.colors, S.x_mirror);
    const weftSource = S.weft_same ? S.warp : (S.weft.length ? S.weft : S.warp);
    const weftRGB = expandToColorPerPixel(weftSource, S.colors, S.y_mirror);

    const img = ctx.createImageData(W,H);
    const data = img.data;

    // Weaving illusion parameters (tweak to taste)
    const baseMix = 0.55;   // how much weft influences intersection color
    const shadeAmt = 0.10;  // subtle depth
    const twillOn = (S.twill === '1x1');

    for(let y=0; y<H; y++){
      const cy = weftRGB[y % weftRGB.length];
      for(let x=0; x<W; x++){
        const cx = warpRGB[x % warpRGB.length];

        // Combine warp + weft
        let c = mix(cx, cy, baseMix);

        // Twill 1x1: alternating dominance (like over-under)
        if(twillOn){
          const overWeft = ((x + y) & 1) === 0;
          c = overWeft ? mix(cx, cy, 0.70) : mix(cx, cy, 0.40);
        }

        // Add tiny “thread” shading
        const rib = ((x % 6) === 0) || ((y % 6) === 0);
        c = rib ? darken(c, shadeAmt) : lighten(c, shadeAmt * 0.5);

        const idx = (y*W + x)*4;
        data[idx+0] = c.r;
        data[idx+1] = c.g;
        data[idx+2] = c.b;
        data[idx+3] = 255;
      }
    }
    ctx.putImageData(img,0,0);

    // Update URL hash live (so it behaves like PlaidMaker)
    const newHash = serializeToHash();
    if(location.hash !== newHash) history.replaceState(null,'', newHash);
  }

  // Debounced render
  let t = null;
  function schedule(force=false){
    if(force){ render(); return; }
    clearTimeout(t);
    t = setTimeout(render, 60);
  }

  // ---------- Init ----------
  const parsed = parseHash();
  if(!parsed) S = structuredClone(DEFAULT);
  syncUI();
  schedule(true);
</script>
</body>
</html>
